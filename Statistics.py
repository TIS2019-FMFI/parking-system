from Record import Recordfrom Box import Boxfrom datetime import datefrom Finder import Finderfrom Database import Databaseimport osimport datetimeimport csvimport ctypes.wintypesCSIDL_PERSONAL= 5       # My DocumentsSHGFP_TYPE_CURRENT= 0class Statistics:    #treba vymyslieť daycount    def __init__(self, ecvTime, ecvNum, firmTime, firmNum, box, boxTime, ztp, ztpFirm, boxes, fromDate= None, toDate= None):        self.db = Database("kvant.db")                self.ecvTime = ecvTime        self.ecvNum = ecvNum        self.firmTime = firmTime        self.firmNum = firmNum        self.box = box        self.boxTime = boxTime        self.ztp = ztp        self.boxes = boxes        self.ztpFirm = ztpFirm        self.fromDate = fromDate        self.dayCount = int((toDate - fromDate).days)        self.toDate = toDate        self.f = Finder()        self.generate()    def generate(self):        den = date.today()        textDen = str(den)        buf = ctypes.create_unicode_buffer(ctypes.wintypes.MAX_PATH)        ctypes.windll.shell32.SHGetFolderPathW(0, CSIDL_PERSONAL, 0, SHGFP_TYPE_CURRENT, buf)        path = buf.value + '\\Parkovanie\\'        newPath = path + '\\exports\\' + textDen        if not os.path.exists(newPath):                os.makedirs(newPath)        if self.ecvTime:            self.exportFile(newPath + '\\' +'ECV porusujuce parkovanie - celkovy cas.csv', ['EČV','Celkový čas parkovania'], self.ecvByTime())        if self.ecvNum:            self.exportFile(newPath + '\\' +'ECV porusujuce parkovanie - pocet.csv', ['EČV','Celkový počet parkovaní'], self.ecvByCount())        if self.firmTime:            self.exportFile(newPath + '\\' +'Firma porusujuca parkovanie - celkovy cas.csv', ['ID', 'Názov firmy', 'Celkový čas parkovania'], self.firmByTime())        if self.firmNum:            self.exportFile(newPath + '\\' +'Firma porusujuca parkovanie - pocet.csv', ['ID', 'Názov firmy', 'Celkový počet parkovaní'], self.firmByCount())        #if self.box:            #self.exportFile(newPath + '\\' +'everyBox.csv', ['Box','%'], self.everyBox(self.dayCount))        if self.boxTime:            self.exportFile(newPath + '\\' +'Obsadenosť boxov.csv', ['ID', 'Označenie', 'Firma', 'Obsadenosť v %'], self.boxInTime(self.fromDate, self.toDate))        if self.ztp:            self.exportFile(newPath + '\\' +'Obsadenosť ZŤP boxov.csv', ['ID', 'Označenie', 'Firma', 'Obsadenosť v %'], self.ztpBox(self.fromDate, self.toDate))        #if self.ztpFirm:            #self.exportFile(newPath + '\\' +'zptByFirm.csv', ['Firma','%'], self.ztpByFirm(self.dayCount))    def exportFile(self, name, names, data):        with open(name, mode = 'w',newline='') as file:            writer = csv.writer(file, delimiter = ';', quotechar = '"', quoting = csv.QUOTE_MINIMAL)            writer.writerow([str(self.fromDate)+" - "+str(self.toDate)])            writer.writerow(names)            if len(data) > 0:                for i in data:                    writer.writerow(i)    # Najde tie, ktore najviac porusovali parkovania (podla casu)    def ecvByTime(self):        records = self.f.findAllWithStatus(self.fromDate, self.toDate, "wrong")        stats = dict()        for rec in records:            totalTime = self.__chopMicroseconds(rec.departureTime - rec.arrivalTime)            if rec.ECV in stats:                stats[rec.ECV] += totalTime            else:                stats[rec.ECV] = totalTime        sortedStats = sorted(stats.items(), key = lambda kv: kv[1], reverse = True)        return sortedStats    # Najde tie, ktore najviac porusovali parkovanie (podla poctu)    def ecvByCount(self):        records = self.f.findAllWithStatus(self.fromDate, self.toDate, "wrong")        stats = dict()        for rec in records:            if rec.ECV in stats:                stats[rec.ECV] += 1            else:                stats[rec.ECV] = 1        sortedStats = sorted(stats.items(), key = lambda kv: kv[1], reverse = True)        return sortedStats    # Zrata celkovo za firmu    # Najdie tie, ktore porusovali parkovanie (podla casu)    def firmByTime(self):        records = self.f.findAllWithStatus(self.fromDate, self.toDate, "wrong")        stats = dict()        for rec in records:            totalTime = self.__chopMicroseconds(rec.departureTime - rec.arrivalTime)            if rec.companyId in stats:                stats[rec.companyId] += totalTime            else:                stats[rec.companyId] = totalTime        sortedStats = sorted(stats.items(), key = lambda kv: kv[1], reverse = True)        return self.__getSortedWithCompanyName(sortedStats)    # Zrata celkovo za firmu    # Najdie tie, ktore porusovali parkovanie (podla poctu)    def firmByCount(self):        records = self.f.findAllWithStatus(self.fromDate, self.toDate, "wrong")        stats = dict()        for rec in records:            if rec.companyId in stats:                stats[rec.companyId] += 1            else:                stats[rec.companyId] = 1        sortedStats = sorted(stats.items(), key = lambda kv: kv[1], reverse = True)        return self.__getSortedWithCompanyName(sortedStats)    def everyBox(self, dayCount):        records = self.f.findAll(self.fromDate, self.toDate)        stats = dict()        for rec in records:            if rec.boxId in stats:                #stats[rec.boxId] = stats[rec.boxId] + (((rec.departureTime - rec.arrivalTime)/24)/dayCount)                stats[rec.boxId] = stats[rec.boxId] + ((rec.departureTime - rec.arrivalTime)/24)            else:                #stats[rec.boxId] = (((rec.departureTime - rec.arrivalTime)/24)/dayCount)                #ked to bude zle tak sorry                stats[rec.boxId] = ((rec.departureTime - rec.arrivalTime)/24)        sortedStats = sorted(stats.items(), key = lambda kv: kv[1], reverse = True)        return sortedStats                    # Obsadenost boxov v danom casovom obdoby vyjadrena v percentach                def boxInTime(self, startRegion, endRegion):        records = self.f.findAll(self.fromDate, self.toDate)        stats = dict()        startParking = None        endParking = None        for rec in records:            # Zaciatok parkovania skorej, ako koniec casoveho ramca            if rec.arrivalTime < endRegion:                # Koniec parkovania neskor, ako zaciatok casoveho ramca                if rec.departureTime > startRegion:                    # Ak je koniec parkovania neskor ako koniec casoveho ramca, nastav koncovy cas na koniec casoveho ramca                    if rec.departureTime > endRegion:                        endParking = endRegion                    else:                        endParking = rec.departureTime                    # Ak je zaciatok parkovania neskor, ako zaciatok casoveho ramca, tak nastav zaciatocny stav na zaciatok parkovania                        if rec.arrivalTime > startRegion:                        #startParking = startRegion                        startParking = rec.arrivalTime                    else:                        #startParking = rec.arrivalTime                        startParking = startRegion                    percentage = round(((endParking - startParking)/(endRegion - startRegion)) * 100, 2)                    if rec.boxId in stats:                        stats[rec.boxId] += percentage                    else:                        stats[rec.boxId] = percentage        sortedStats = sorted(stats.items(), key = lambda kv: kv[1], reverse = True)        return self.__getSortedDataWithInfoAboutBox(sortedStats)    # Obsadenost ZTP boxov v danom casovom obdoby vyjadrena v percentach        def ztpBox(self, startRegion, endRegion):        records = self.f.findAll(self.fromDate, self.toDate)        stats = dict()        ztpBoxes = set()        for box in self.boxes:            if box.invalid:                ztpBoxes.add(box.boxId)                stats[box.boxId] = 0        startParking = None        endParking = None        for rec in records:            # Ak je to ZTP box            if box.boxId in ztpBoxes:                # Zaciatok parkovania skorej, ako koniec casoveho ramca                if rec.arrivalTime < endRegion:                    # Koniec parkovania neskor, ako zaciatok casoveho ramca                    if rec.departureTime > startRegion:                        # Ak je koniec parkovania neskor ako koniec casoveho ramca, nastav koncovy cas na koniec casoveho ramca                        if rec.departureTime > endRegion:                            endParking = endRegion                        else:                            endParking = rec.departureTime                        # Ak je zaciatok parkovania neskor, ako zaciatok casoveho ramca, tak nastav zaciatocny stav na zaciatok parkovania                            if rec.arrivalTime > startRegion:                            #startParking = startRegion                            startParking = rec.arrivalTime                        else:                            #startParking = rec.arrivalTime                            startParking = startRegion                        percentage = round(((endParking - startParking)/(endRegion - startRegion)) * 100, 2)                        if rec.boxId in stats:                            stats[rec.boxId] += percentage                        else:                            stats[rec.boxId] = percentage        sortedStats = sorted(stats.items(), key = lambda kv: kv[1], reverse = True)        return self.__getSortedDataWithInfoAboutBox(sortedStats)                    def ztpByFirm(self, dayCount):        print("ZTP by Firm")        records = self.f.findAll(self.fromDate, self.toDate)        stats = dict()        ztpBoxes = set()        for box in self.boxes:            if box.invalid:                ztpBoxes.add(box.boxId)            for rec in records:            if rec.boxId in ztpBoxes:                if rec.companyId in stats:                    stats[rec.companyId] = stats[rec.companyId] + (((rec.departureTime - rec.arrivalTime)/24)/dayCount)                else:                    stats[rec.companyId] = (((rec.departureTime - rec.arrivalTime)/24)/dayCount)        sortedStats = sorted(stats.items(), key = lambda kv: kv[1], reverse = True)        return sortedStats    # Pomocna metoda na zbavenia sa mikrosekund v case    def __chopMicroseconds(self, delta):        return delta - datetime.timedelta(microseconds=delta.microseconds)    # Vrati sorted data ale s tym, ze prida stlpec pre meno firmy    # id firmy musi byt prve    def __getSortedWithCompanyName(self, sortedData):        result = []        for item in sortedData:            companyName = self.db.getCompanyNameById(item[0])            # Firma ID, Firma Meno, udaj            newItem = (item[0], companyName, item[1])            result.append(newItem)        return result    # Vrati sorted data ale s tym, ze prida stlpce pre boxLabel a meno firmy    # id boxu musi byt prve    def __getSortedDataWithInfoAboutBox(self, sortedData):                def getBox(boxId):            for box in self.boxes:                if(box.boxId == boxId):                    return box                        result = []        for item in sortedData:            box = getBox(item[0])            companyName = self.db.getCompanyNameById(box.companyId)            # boxID, boxLabel, Firma, udaj            newItem = (item[0], box.boxLabel, companyName, item[1])            result.append(newItem)        return result                